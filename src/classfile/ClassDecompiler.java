package classfile;

import classfile.attribute.ConstantValueAttribute;
import classfile.constant.*;
import java.io.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
4.3 The Internal Form of Names
4.3.1 Fully Qualified Class and Interface Names
Class and interface names that appear in class file structures are always represented
in a fully qualified form (§2.7.5). Such names are always represented
as CONSTANT_Utf8_info (§4.5.7) structures and thus may be drawn,
where not further constrained, from the entire Unicode character set. Class names
and interfaces are referenced both from those CONSTANT_NameAndType_info
(§4.5.6) structures that have such names as part of their descriptor (§4.4) and from
all CONSTANT_Class_info (§4.5.1) structures.
For historical reasons the syntax of fully qualified class and interface names that
appear in class file structures differs from the familiar syntax of fully qualified
names documented in §2.7.5. In this internal form, the ASCII periods ('.')
that normally separate the identifiers that make up the fully qualified name are
replaced by ASCII forward slashes ('/'). The identifiers themselves must be
unqualified names as discussed in section (§4.3.2) below. For example, the normal
fully qualified name of class Thread is java.lang.Thread. In the form used in
descriptors in the class file format, a reference to the name of class Thread is
implemented using a CONSTANT_Utf8_info structure representing the string
"java/lang/Thread".

4.3.2 Unqualified Names
Names of methods, fields and local variables are stored as unqualified names.
Unqualified names must not contain the characters '.', ';', '[' or '/'. Method
names are further constrained so that, with the exception of the special method
names (§3.9)(§3.9) <init> and <clinit>, they must not contain the characters
'<' or '>'.


4.4 Descriptors and Signatures
A descriptor is a string representing the type of a field or method. Descriptors are
represented in the class file format using modified UTF-8 strings (§4.5.7) and thus
may be drawn, where not further constrained, from the entire Unicode character set.
A signature is a string representing the generic type of a field or method, or
generic type information for a class declaration.
4.4.1 Grammar Notation
Descriptors and signatures are specified using a grammar. This grammar is a set of
productions that describe how sequences of characters can form syntactically correct
descriptors of various types. Terminal symbols of the grammar are shown in
bold fixed-width font. Nonterminal symbols are shown in italic type. The definition
of a nonterminal is introduced by the name of the nonterminal being defined,
followed by a colon. One or more alternative right-hand sides for the nonterminal
then follow on succeeding lines. For example, the production:
FieldType:
BaseType
ObjectType
ArrayType
states that a FieldType may represent either a BaseType, an ObjectType, or an Array-
Type.
A nonterminal symbol on the right-hand side of a production that is followed by
an asterisk (*) represents zero or more possibly different values produced from
that nonterminal, appended without any intervening space. Similarly, a
nonterminal symbol on the right-hand side of a production that is followed by an
plus sign (+) represents one or more possibly different values produced from that
nonterminal, appended without any intervening space. The production:
MethodDescriptor:
( ParameterDescriptor* ) ReturnDescriptor
states that a MethodDescriptor represents a left parenthesis, followed by zero or
more ParameterDescriptor values, followed by a right parenthesis, followed by a
ReturnDescriptor.

4.4.2 Field Descriptors
A field descriptor represents the type of a class, instance, or local variable. It is a
series of characters generated by the grammar:
FieldDescriptor:
FieldType

ComponentType:
FieldType

FieldType:
BaseType
ObjectType
ArrayType

BaseType:
B
C
D
F
I
J
S
Z

ObjectType:
L Classname;

ArrayType:
[ComponentType

The characters of BaseType, the L and ; of ObjectType, and the [ of ArrayType are all
ASCII characters. The Classname represents a fully qualified class or interface name. For
historical reasons it is encoded in internal form (§4.2). A type descriptor reprenting an
array type is valid only if it represents a type with 255 or fewer dimensions.

The interpretation of the field types is as shown in Table 4.2.
Table 4.2 Interpretation of BaseType characters
BaseType Character Type Interpretation
B byte signed byte
C char Unicode character
D double double-precision floating-point value
F float single-precision floating-point value
I int integer
J long long integer
L Classname; reference an instance of class <classname>
S short signed short
Z boolean true or false
[ reference one array dimension

For example, the descriptor of an instance variable of type int is simply I. The descriptor
of an instance variable of type Object is Ljava/lang/Object;. Note that the internal
form of the fully qualified name for class Object is used. The descriptor of an instance
variable that is a multidimensional double array,
double d[][][];
is
[[[D

4.4.3 Method Descriptors
A method descriptor represents the parameters that the method takes and the value
that it returns:
MethodDescriptor:
( ParameterDescriptor* ) ReturnDescriptor
A parameter descriptor represents a parameter passed to a method:
ParameterDescriptor:
FieldType
A return descriptor represents the type of the value returned from a method. It is a series
of characters generated by the grammar:
ReturnDescriptor:
FieldType
VoidDescriptor
VoidDescriptor:
V
The character V indicates that the method returns no value (its return type is void).
A method descriptor is valid only if it represents method parameters with a total length of
255 or less, where that length includes the contribution for this in the case of instance or
interface method invocations. The total length is calculated by summing the contributions
of the individual parameters, where a parameter of type long or double contributes two
units to the length and a parameter of any other type contributes one unit.
For example, the method descriptor for the method
Object mymethod(int i, double d, Thread t)
is
(IDLjava/lang/Thread;)Ljava/lang/Object;
Note that internal forms of the fully qualified names of Thread and Object are
used in the method descriptor.
The method descriptor for mymethod is the same whether mymethod is a class or an
instance method. Although an instance method is passed this, a reference to the current
class instance, in addition to its intended parameters, that fact is not reflected in the
method descriptor. (A reference to this is not passed to a class method.) The reference
to this is passed implicitly by the method invocation instructions of the Java virtual
machine used to invoke instance methods.



4.4.4 Signatures
Signatures are used to encode Java programming language type information that is
not part of the Java virtual machine type system, such as generic type and method
declarations and parameterized types. See The Java Language Specification, Third
Edition, for details about such types.
This kind of type information is needed to support reflection and
debugging, and by the Java compiler.
In the following, the terminal symbol Identifier is used to denote an identifier
for a type, field, local variable, parameter, method name or type variable, as
generated by the Java compiler. Such an identifier may contain characters that
must not appear in a legal identifier in the Java programming language.
ClassSignature:
FormalTypeParametersopt SuperclassSignature SuperinterfaceSignature*

A class signature, defined by the production ClassSignature above, is used to
encode type information about a class declaration. It gives the fully qualified
name of the class, describes any formal type parameters it the class might have,
and lists its (possibly parameterized) direct superclass and direct superinterfaces,
if any.
FormalTypeParameters:
<FormalTypeParameter+>

FormalTypeParameter:
Identifier ClassBound InterfaceBound*

A formal type parameter is described by its name, followed by its class and
interface bounds. If the class bound does not specify a type, it is taken to be
Object.
ClassBound:
: FieldTypeSignatureopt
InterfaceBound:
: FieldTypeSignature
SuperclassSignature:
ClassTypeSignature
SuperinterfaceSignature:
ClassTypeSignature
FieldTypeSignature:
ClassTypeSignature
ArrayTypeSignature
TypeVariableSignature
A field type signature, defined by the production FieldTypeSignature above,
encodes the (possibly parameterized) type for a field, parameter or local variable.
ClassTypeSignature:
L PackageSpecifier* SimpleClassTypeSignature
ClassTypeSignatureSuffix* ;
PackageSpecifier:
Identifier / PackageSpecifier*
SimpleClassTypeSignature:
Identifier TypeArgumentsopt
ClassTypeSignatureSuffix:
. SimpleClassTypeSignature
TypeVariableSignature:
T Identifier ;
TypeArguments:
<TypeArgument+>
TypeArgument:
WildcardIndicatoropt FieldTypeSignature
 *
WildcardIndicator:
+
-
ArrayTypeSignature:
[TypeSignature
TypeSignature:
FieldTypeSignature
BaseType

A class type signature gives complete type information for a class or interface
type. The class type signature must be formulated such that it can be reliably
mapped to the binary name of the class it denotes by erasing any type arguments
and converting ‘.’ characters in the signature to ‘$’ characters.
MethodTypeSignature:
FormalTypeParametersopt (TypeSignature*) ReturnType
ThrowsSignature*
ReturnType:
TypeSignature
VoidDescriptor
ThrowsSignature:
^ClassTypeSignature
^TypeVariableSignature
A method signature, defined by the production MethodTypeSignature above,
encodes the (possibly parameterized) types of the method’s formal arguments and
of the exceptions it has declared in its throws clause, its (possibly parameterized)
return type, and any formal type parameters in the method declaration.
A Java compiler must output generic signature information for any class,
interface, consructor or member whose generic signature would include
references to type variables or parameterized types. If the throws clause of a
method or constructor does not involve type variables, the ThowsSignature may
be elided from the MethodTypeSignature.
The Java virtual machine does not check the well formedness of the signatures
described in this subsection during loading or linking. Instead, these checks are
deferred until the signatures are used by reflective methods, as specified in the
API of Class and members of java.lang.reflect. Future versions of the Java
virtual machine may be required to performs some or all of these checks during
loading or linking.
 */
public class ClassDecompiler {

    private static final String DIMENSION_TEXT = "[][][][][][][][]";

    //TODO: check if false = 0
    public static final boolean getBoolean(ClassFile cf, short cpiIndex) {
        IntegerInfo ii = (IntegerInfo) cf.getCpInfo(cpiIndex);
        return ii.bytes != 0;
    }

    //TODO: check if bit mask is needed
    public static final byte getByte(ClassFile cf, short cpiIndex) {
        IntegerInfo ii = (IntegerInfo) cf.getCpInfo(cpiIndex);
        return (byte) ii.bytes;
    }

    //TODO: check if bit mask is needed
    public static final char getChar(ClassFile cf, short cpiIndex) {
        IntegerInfo ii = (IntegerInfo) cf.getCpInfo(cpiIndex);
        return (char) ii.bytes;
    }

    //TODO: check if bit mask is needed
    public static final short getShort(ClassFile cf, short cpiIndex) {
        IntegerInfo ii = (IntegerInfo) cf.getCpInfo(cpiIndex);
        return (short) ii.bytes;
    }

    //TODO: check if correct
    public static final int getInt(ClassFile cf, short cpiIndex) {
        IntegerInfo ii = (IntegerInfo) cf.getCpInfo(cpiIndex);
        return ii.bytes;
    }

    //TODO: check if correct
    public static final float getFloat(ClassFile cf, short cpiIndex) {
        FloatInfo fi = (FloatInfo) cf.getCpInfo(cpiIndex);
        return Float.intBitsToFloat(fi.bytes);
    }

    //TODO: check if correct
    public static final long getLong(ClassFile cf, short cpiIndex) {
        LongInfo li = (LongInfo) cf.getCpInfo(cpiIndex);
        return ((long) li.highBytes << 32) | (0xffffffffL & li.lowBytes);
    }

    //TODO: check if correct
    public static final Double getDouble(ClassFile cf, short cpiIndex) {
        DoubleInfo di = (DoubleInfo) cf.getCpInfo(cpiIndex);
        return Double.longBitsToDouble(((long) di.highBytes << 32) | (0xffffffffL & di.lowBytes));
    }

    public static final String getUtf8(ClassFile cf, short cpiIndex) {
        Utf8Info ui = (Utf8Info) cf.getCpInfo(cpiIndex);
        try {
            return new String(ui.bytes, "UTF-8");
        } catch (UnsupportedEncodingException ex) {
            Logger.getLogger(ClassDecompiler.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    public static final String getString(ClassFile cf, short cpiIndex) {
        StringInfo si = (StringInfo) cf.getCpInfo(cpiIndex);
        return getUtf8(cf, si.stringIndex);
    }

    //TODO: handle inner class name properly
    public static final String getFullyQualifiedClassName(ClassFile cf, short cpIndex) {
        ClassInfo ci = (ClassInfo) cf.getCpInfo(cpIndex);
        short nameIndex = ci.nameIndex;
        String className = getUtf8(cf, nameIndex);
        return className != null ? className.replace('/', '.') : null;
    }

    //TODO: handle inner class name properly
    public static final String getUnqualifiedClassName(ClassFile cf, short cpIndex) {
        ClassInfo ci = (ClassInfo) cf.getCpInfo(cpIndex);
        short nameIndex = ci.nameIndex;
        String className = getUtf8(cf, nameIndex);
        /*if (className != null) {
        int i = className.lastIndexOf('.');
        return i != -1 ? className.substring(i + 1) : className;
        } else {
        return null;
        }*/
        int i;
        return className != null && (i = className.lastIndexOf('/')) >= 0 ? className.substring(i + 1) : className;
    }

    public static final String getPackageName(ClassFile cf, short cpIndex) {
        ClassInfo ci = (ClassInfo) cf.getCpInfo(cpIndex);
        short nameIndex = ci.nameIndex;
        String className = getUtf8(cf, nameIndex);
        int i;
        return className != null && (i = className.lastIndexOf('/')) >= 0 ? className.substring(0, i).replace('/', '.') : null;
    }

    public static final String getClassAccessText(short accessFlags) {
        StringBuilder buf = new StringBuilder();
        if ((accessFlags & ClassFile.ACC_PUBLIC) != 0) {
            buf.append("public ");
        }

        //if ((accessFlags & ClassFile.ACC_SUPER) != 0) {
        //    buf.append("/*super*/ ");
        //}

        //if ((accessFlags & ClassFile.ACC_SYNTHETIC) != 0) {
        //    buf.append("/*sythetic*/ ");
        //}

        if ((accessFlags & ClassFile.ACC_ENUM) != 0) {
            buf.append("enum ");
        } else if ((accessFlags & ClassFile.ACC_INTERFACE) == 0) {
            if ((accessFlags & ClassFile.ACC_FINAL) != 0) {
                buf.append("final ");
            }
            if ((accessFlags & ClassFile.ACC_ABSTRACT) != 0) {
                buf.append("abstract ");
            }
            buf.append("class ");
        } else if ((accessFlags & ClassFile.ACC_ANNOTATION) == 0) {
            buf.append("interface ");
        } else {
            buf.append("@interface ");
        }
        return buf.toString();
    }

    public static void decompile(ClassFile cf, PrintWriter out) {
        String fullyQualifiedClassName = getFullyQualifiedClassName(cf, cf.thisClass);
        String packageName = getPackageName(cf, cf.thisClass);
        if (packageName != null) {
            out.print("package ");
            out.print(packageName);
            out.println(';');
        }

        short accessFlags = cf.accessFlags;
        out.print(getClassAccessText(accessFlags));

        out.print(getUnqualifiedClassName(cf, cf.thisClass));
        out.print(' ');
        if ((accessFlags & (ClassFile.ACC_ENUM | ClassFile.ACC_ANNOTATION)) == 0) {
            String superClassName = getFullyQualifiedClassName(cf, cf.superClass);
            if (!superClassName.equals("java.lang.Object")) {
                out.print("extends ");
                out.print(superClassName);
                out.print(' ');
            }
        }

        if ((accessFlags & (ClassFile.ACC_ENUM | ClassFile.ACC_ANNOTATION)) == 0 && cf.interfacesCount > 0) {
            if ((accessFlags & ClassFile.ACC_INTERFACE) == 0) {
                out.print("implements ");
            } else {
                out.print("extends ");
            }
            short[] interfaces = cf.interfaces;
            short ciIndex = interfaces[0];
            String interfaceName = getFullyQualifiedClassName(cf, ciIndex);
            out.print(interfaceName);
            for (int i = 1, count = interfaces.length; i < count; ++i) {
                out.print(", ");
                ciIndex = interfaces[i];
                interfaceName = getFullyQualifiedClassName(cf, ciIndex);
                out.print(interfaceName);
            }
            out.print(' ');
        }

        out.println("{");
        decompileFields(cf, out);
        decompileMethods(cf, out);
        decompileAnnotations(cf, out);
        out.println("}");
        out.flush();
    }

    public static final String getFieldAccessText(short accessFlags) {
        StringBuilder buf = new StringBuilder();
        if ((accessFlags & FieldInfo.ACC_PUBLIC) != 0) {
            buf.append("public ");
        }

        if ((accessFlags & FieldInfo.ACC_PRIVATE) != 0) {
            buf.append("private ");
        }

        if ((accessFlags & FieldInfo.ACC_PROTECTED) != 0) {
            buf.append("protected ");
        }

        if ((accessFlags & FieldInfo.ACC_STATIC) != 0) {
            buf.append("static ");
        }

        if ((accessFlags & FieldInfo.ACC_FINAL) != 0) {
            buf.append("final ");
        }

        if ((accessFlags & FieldInfo.ACC_VOLATILE) != 0) {
            buf.append("volatile ");
        }

        if ((accessFlags & FieldInfo.ACC_TRANSIENT) != 0) {
            buf.append("transient ");
        }

        //if ((accessFlags & FieldInfo.ACC_SYNTHETIC) != 0) {
        //    buf.append("/*synthetic*/ ");
        //}
        //if ((accessFlags & FieldInfo.ACC_ENUM) != 0) {
        //    buf.append("/*enum*/ ");
        //}

        return buf.toString();
    }

    /** A field descriptor represents the type of a class, instance, or local variable. It is a
    series of characters generated by the grammar:
    FieldDescriptor:
    FieldType

    ComponentType:
    FieldType

    FieldType:
    BaseType
    ObjectType
    ArrayType

    BaseType:
    B
    C
    D
    F
    I
    J
    S
    Z

    ObjectType:
    L Classname;

    ArrayType:
    [ComponentType

    The characters of BaseType, the L and ; of ObjectType, and the [ of ArrayType are all
    ASCII characters. The Classname represents a fully qualified class or interface name. For
    historical reasons it is encoded in internal form (§4.2). A type descriptor reprenting an
    array type is valid only if it represents a type with 255 or fewer dimensions.

    The interpretation of the field types is as shown in Table 4.2.
    BaseType Character Type Interpretation
    B byte signed byte
    C char Unicode character
    D double double-precision floating-point value
    F float single-precision floating-point value
    I int integer
    J long long integer
    L Classname; reference an instance of class <classname>
    S short signed short
    Z boolean true or false
    [ reference one array dimension

    For example, the descriptor of an instance variable of type int is simply I. The descriptor
    of an instance variable of type Object is Ljava/lang/Object;. Note that the internal
    form of the fully qualified name for class Object is used. The descriptor of an instance
    variable that is a multidimensional double array,
    double d[][][];
    is
    [[[D
     */
    public static String getFieldTypeText(ClassFile cf, short descriptorIndex) {
        // The regexp of field descriptor (no validation on number of dimensions and characters of <classname>) is \[?[BCDFIJSZ]|L[^;]+;
        String descriptor = getUtf8(cf, descriptorIndex);
        if (descriptor != null && descriptor.length() > 0) {
            char[] descriptorBytes = descriptor.toCharArray();
            int dimensionCount = 0;
            char c = descriptorBytes[0];
            int idx = 0;
            int len = descriptorBytes.length;
            for (; idx++ < len && c == '['; c = descriptorBytes[idx]) {
                ++dimensionCount;
            }
            String type;
            switch (c) {
                case 'B':
                    type = "byte";
                    break;
                case 'C':
                    type = "char";
                    break;
                case 'D':
                    type = "double";
                    break;
                case 'F':
                    type = "float";
                    break;
                case 'I':
                    type = "int";
                    break;
                case 'J':
                    type = "long";
                    break;
                case 'S':
                    type = "short";
                    break;
                case 'Z':
                    type = "boolean";
                    break;
                case 'L':
                    int oidx = idx;
                    for (; idx < len && c != ';'; c = descriptorBytes[++idx]) {
                    }
                    type = descriptor.substring(oidx, idx).replace('/', '.');
                    break;
                default:
                    type = "";
            }

            if (dimensionCount > 0) {
                int dLen = DIMENSION_TEXT.length();
                int dimensionLen = dimensionCount << 1;
                if (dimensionLen <= dLen) {
                    type += DIMENSION_TEXT.substring(0, dimensionLen);
                } else {
                    StringBuilder buf = new StringBuilder();
                    do {
                        buf.append(DIMENSION_TEXT, 0, dimensionLen > dLen ? dLen : dimensionLen);
                        dimensionLen -= dLen;
                    } while (dimensionLen > 0);
                    type += buf.toString();
                }
            }
            return type;
        }
        return null;
    }

    //TODO: handle other attributes
    private static void decompileFields(ClassFile cf, PrintWriter out) {
        FieldInfo[] fields = cf.fields;
        for (FieldInfo field : fields) {
            out.print(getFieldAccessText(field.accessFlags));
            String fieldName = getUtf8(cf, field.nameIndex);
            String fieldTypeText = getFieldTypeText(cf, field.descriptorIndex);
            out.print(fieldTypeText);
            out.print(' ');
            out.print(fieldName);

            if (field.attributes != null) {
                String descriptor = getUtf8(cf, field.descriptorIndex);
                for (AttributeInfo ai : field.attributes) {
                    if (ai instanceof ConstantValueAttribute) {
                        out.print(" = ");
                        ConstantValueAttribute cva = (ConstantValueAttribute) ai;
                        //\[?[BCDFIJSZ]|L[^;]+;
                        if ("B".equals(descriptor)) {
                            byte b = getByte(cf, cva.constantValueIndex);
                            out.print(Byte.MAX_VALUE==b ? "Byte.MAX_VALUE" : Byte.MIN_VALUE==b ? "Byte.MIN_VALUE" : b);//TODO: allow whether encode min max or not
                        } else if ("C".equals(descriptor)) {
                            char c = getChar(cf, cva.constantValueIndex);
                            out.print(Character.MAX_VALUE==c ? "Character.MAX_VALUE" : Character.MIN_VALUE==c ? "Character.MIN_VALUE" : "'"+Character.toString(c)+"'");
                        } else if ("D".equals(descriptor)) {
                            double d = getDouble(cf, cva.constantValueIndex);
                            out.print(Double.isInfinite(d) ? (d > 0 ? "Double.POSITIVE_INFINITY" : "Double.NEGATIVE_INFINITY") : Double.isNaN(d) ? "Double.NaN" : Double.toString(d));//TODO: allow whether encode infinities and NaN, and other constants or not
                        } else if ("F".equals(descriptor)) {
                            //TODO: allow without "F" if value within float range; encode NaN
                            //TODO: allow whether encode infinities and NaN, and other constants or not
                            float f = getFloat(cf, cva.constantValueIndex);
                            out.print(Float.isInfinite(f) ? f > 0 ? "Float.POSITIVE_INFINITY" : "Float.NEGATIVE_INFINITY" : Float.isNaN(f) ? "Float.NaN" : Float.toString(f)+"F");
                        } else if ("I".equals(descriptor)) {
                            int i = getInt(cf, cva.constantValueIndex);
                            out.print(Integer.MAX_VALUE==i ? "Integer.MAX_VALUE" : Integer.MIN_VALUE==i ? "Integer.MIN_VALUE" : Integer.toString(i));//TODO: allow whether encode min max or not
                        } else if ("J".equals(descriptor)) {
                            //TODO: allow without "L" if value within int range
                            //TODO: allow whether encode min max or not
                            long j = getLong(cf, cva.constantValueIndex);
                            out.print(Long.MAX_VALUE==j ? "Long.MAX_VALUE" : Long.MIN_VALUE==j ? "Long.MIN_VALUE" : Long.toString(j)+"L");
                        } else if ("S".equals(descriptor)) {
                            //TODO: allow whether encode min max or not
                            short s = getShort(cf, cva.constantValueIndex);
                            out.print(Short.MAX_VALUE==s ? "Short.MAX_VALUE" : Short.MIN_VALUE==s ? "Short.MIN_VALUE" : Long.toString(s));
                        } else if ("Z".equals(descriptor)) {
                            out.print(getBoolean(cf, cva.constantValueIndex));
                        } else if (descriptor.charAt(0) == 'L') {
                            //TODO: Maight not be String; encode unprintable characters
                            out.print('"');
                            out.print(getString(cf, cva.constantValueIndex));
                            out.print('"');
                        } else {
                            //TODO: ?
                            out.print("TODO:decompileFields");
                        }
                    }
                }
            }

            out.println(';');
        }
    }

    public static final String getMethodAccessText(short accessFlags) {
        StringBuilder buf = new StringBuilder(60);

        if ((accessFlags & MethodInfo.ACC_PUBLIC) != 0) {
            buf.append("public ");
        }

        if ((accessFlags & MethodInfo.ACC_PRIVATE) != 0) {
            buf.append("private ");
        }

        if ((accessFlags & MethodInfo.ACC_PROTECTED) != 0) {
            buf.append("protected ");
        }

        if ((accessFlags & MethodInfo.ACC_STATIC) != 0) {
            buf.append("static ");
        }

        if ((accessFlags & MethodInfo.ACC_FINAL) != 0) {
            buf.append("final ");
        }

        if ((accessFlags & MethodInfo.ACC_SYNCHRONIZED) != 0) {
            buf.append("synchronized ");
        }

        //if ((accessFlags & MethodInfo.ACC_BRIDGE) != 0) {
        //    buf.append("/*bridge*/ ");
        //}

        //if ((accessFlags & MethodInfo.ACC_VARARGS) != 0) {
        //    buf.append("/*varargs*/ ");
        //}

        if ((accessFlags & MethodInfo.ACC_NATIVE) != 0) {
            buf.append("native ");
        }


        if ((accessFlags & MethodInfo.ACC_ABSTRACT) != 0) {
            buf.append("abstract ");
        }

        if ((accessFlags & MethodInfo.ACC_STRICT) != 0) {
            buf.append("strict ");
        }


        //if ((accessFlags & MethodInfo.ACC_SYNTHETIC) != 0) {
        //    buf.append("/*synthetic*/ ");
        //}
        return buf.toString();
    }

    private static void decompileMethods(ClassFile cf, PrintWriter out) {
    }

    private static void decompileAnnotations(ClassFile cf, PrintWriter out) {
    }

    public static void decompile(DataInputStream in, PrintWriter out) throws IOException {
        ClassReader cr = new ClassReader();
        ClassFile cf = cr.read(in);
        decompile(cf, out);
    }

    private static void normalizeSourceText(Reader r, PrintWriter pw) {
        try {
            BufferedReader br = new BufferedReader(r);
            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.length() > 0) {
                    pw.println(line);
                }
            }
        } catch (IOException ex) {
            Logger.getLogger(ClassDecompiler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private static String loadNormalizeSourceText(File f) {
        FileReader fr = null;
        try {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            fr = new FileReader(f);
            normalizeSourceText(fr, pw);
            return sw.getBuffer().toString();
            /*StringWriter sw = new StringWriter();
            String line;
            try {
            BufferedReader br = new BufferedReader(new FileReader(f));
            PrintWriter pw = new PrintWriter(sw);
            while ((line = br.readLine()) != null) {
            //if (line.length() > 0) {
            pw.println(line);
            //}
            }
            pw.close();
            } catch (FileNotFoundException ex) {
            Logger.getLogger(ClassDecompiler.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
            Logger.getLogger(ClassDecompiler.class.getName()).log(Level.SEVERE, null, ex);
            }
            return sw.getBuffer().toString();
             */
        } catch (FileNotFoundException ex) {
            Logger.getLogger(ClassDecompiler.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                fr.close();
            } catch (IOException ex) {
                Logger.getLogger(ClassDecompiler.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return null;

    }

    public static void main(String[] args) throws IOException {
        StringWriter sw = new StringWriter();
        File srcDir = new File("src");

        File classDir = new File("build/classes");
        for (File f : classDir.listFiles()) {
            String fn = f.getName();
            if (f.isFile() && !fn.contains("$") && fn.endsWith(".class")) {
                ClassDecompiler.decompile(new DataInputStream(new FileInputStream(f)), new PrintWriter(sw));
                StringBuffer dBuf = sw.getBuffer();

                StringWriter sw2 = new StringWriter();
                normalizeSourceText(new StringReader(dBuf.toString()), new PrintWriter(sw2));
                dBuf.setLength(0);
                dBuf = sw2.getBuffer();


                String srcFn = fn.replaceFirst("\\.class$", ".java");
                String srcText = loadNormalizeSourceText(new File(srcDir, srcFn));

                if (srcText.equals(dBuf.toString())) {
                    System.out.println(fn + " passed");
                } else {
                    System.out.println(fn + " failed");
                    System.out.println("[" + srcText + "]");
                    System.out.println("[" + dBuf + "]");
                }
                dBuf.setLength(0);
            }
        }
    }
}
